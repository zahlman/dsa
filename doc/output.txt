This work is licensed under the Creative Commons
Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy
of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/

Overview
--------

When `dsd` (the DSA disassembler) is run, a disassembly listing is produced
which represents the contents of one or more "chunks" of a source binary file.
The listing is formatted according to the general principles described in
`files.txt`, with a block of lines corresponding to each chunk. This document
describes the format of each such block of text, which we will call a
*disassembly block*.

The disassembly block format
----------------------------

A disassembly block consists of one or more meta lines, zero or more indented
or unindented lines, and one final meta line which "closes" the block.
Indented and unindented lines are treated identically. Empty lines are
ignored, whether between or within the lines of a block.

The meta lines at the start of the block are called the *block header*. They
consist of zero or more *filter specification* lines, followed by a single
*interpreter specification* line.

The subsequent non-meta lines are called the *block content*. The interpreter
specification line, of course, determines which interpreter is used to
interpret the block content (see `interpreters.txt` for details).

The final line is called the *block footer*. It must not have any content, but
it may be commented. (The disassembler comments these lines with the offset in
the original binary corresponding to the end of the disassembled chunk.)

Filter specifications
---------------------

Filter specifications appear in the order that filters were used when
disassembling; correspondingly, when the data is asssembled, the filters will
be applied from the bottom up (or from the inside out, if you prefer).

Tokens on a filter specification line must not be labels. The first token
gives the name of the filter; subsequent tokens give parameters used to
configure the filter. The filter implementation determines what parameters are
written during disassembly and how they will be interpreted during assembly.
The parameters need not match the ones used to configure the filter for
disassembly.

Interpreter specifications
--------------------------

The interpreter specification has three tokens: a label which identifies the
chunk, a number indicating the *chunk offset* (location in the source binary
where the chunk's data starts), and the interpreter name. The name token may
have additional parts with configuration info for the interpreter. Because
this line starts with a label, the assembler has an easy way to determine that
the "chain" of filter specifications has ended and that this is the last line
of the chunk header.

Notes on disassembly
--------------------

Although the label names used for blocks do not have inherent meaning, the
names generated by `dsd` follow some conventions. The "root" block where
disassembly starts will be labelled `main`. The names of other blocks - where
the corresponding chunk was found by following pointers - will be determined
by the structgroup (other interpreters do not normally generate labels). In
the case of a conflict, new names will be generated by appending a base-10
integer value starting at `2` and counting upward. So, for example, an attempt
to produce a second chunk labelled with `@main` will result in `@[main 2]`,
then `@[main 3]` and so on.

Examples
--------

1. The standard library `string` interpreter might produce a block that looks
like:

!@main 0x0 [string, ascii, basic]
'This is a [Open]test[Close].[NL]'
!# 0x13

Here, no filters are applied to the chunk. The `string` interpreter was
configured to use `ascii` string encoding and the `basic` string codec (see
`interpreters.txt` and `codecs.txt` for details), and will use those settings
when re-assembling the block.

The block represents a chunk of binary data spanning the first 19 bytes of the
file (note that the chunk offset is zero, and the underlying binary data would
include a null terminator). This length (rather, the offset of the end of the
chunk) is commented out in the block footer.

The block is labelled `main`; the content of other chunks may reference this
label. (See `interpreters.txt` for details on how label references work.)

2. Consider the following hypothetical disassembly listing:

!@main 0x0 [data pointer]
DATA @data
!# 0x4

!size 32
!@data 0x4 hex
HEXD 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
HEXD 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F
!# 0x24

Here, a hypothetical structgroup-based interpreter named `data pointer`
disassembled into a single `DATA` struct, containing a single member which was
a pointer to the `data` chunk. The pointer's type specifies that the built-in
`size` filter should be used, to label the size of the chunk explicitly on
disassembly and verify it on assembly (see `filters.txt` for details). The
listing, therefore, adds this filter to the `data` block's header.

The built-in `hex` interpreter used by the `data` block is also
structgroup-based. It produces `HEXD` structs, thus displaying a hex dump of
the chunk data (see `interpreters.txt` for details).
