# Copyright (C) 2018-2020 Karl Knechtel
# Licensed under the Open Software License version 3.0

from .entrypoint import entry_point, param
from .location import get as root
from ..errors import UserError
from os.path import join as join_path, abspath as fix_path


class MANDATORY_PATH(UserError):
    """The path to the system libraries may not be removed"""


def _library():
    return fix_path(join_path(root(), 'library'))


def _extfile():
    return join_path(_library(), 'libpaths.txt')


def _save_paths(paths):
    with open(_extfile(), 'w') as f:
        f.write('# This file is automatically generated. Do not edit.\n')
        f.write('\n')
        for path in sorted(paths):
            f.write(f'{path}\n')


def _load_paths():
    try:
        with open(_extfile()) as f:
            return {
                line for line in (path.rstrip() for path in f)
                if line != '' and not line.startswith('#')
            }
    except FileNotFoundError:
        result = {'.'}
        _save_paths(result)
        return result


def fixed_roots():
    return [fix_path(join_path(_library(), r)) for r in _load_paths()]


@param('path', 'path to use (should be absolute)')
@entry_point('Data Structure Assembler - add library path')
def use_files(path):
    paths = _load_paths()
    if path not in paths:
        paths.add(path)
        _save_paths(paths)


@param('path', 'path to stop using (should be absolute)')
@entry_point('Data Structure Assembler - remove library path')
def drop_files(path):
    MANDATORY_PATH.require(path != '.')
    paths = _load_paths()
    if path in paths:
        paths.remove(path)
        _save_paths(paths)
